    (res *> (⊗))  = let f res = ⟨ Nil -> res | x::xs -> f (res⊗x) xs ⟩ in f res;
    foldl (⊗) res = (res *> (⊗));
    
    ((⊗) <* res)  = let f = ⟨ Nil -> res | x::xs -> x ⊗ f xs ⟩ in f;
    foldr (⊗) res = ((⊗) <* res);
    
    map f = λ(  Nil    -> Nil 
             |  x::xs ->  f x :: map f xs
             );
                
    len = λ ( Nil      -> 0 
            | _ :: xs -> 1+len xs 
            );

    take n xs =
        if null xs then Nil else 
        if n=0     then Nil else
           hd xs :: take (n-1) (tl xs) ;  
           
    drop n xs = 
        if n=0     then xs else 
        if null xs then xs else 
           drop (n-1) (tl xs);

    (++) = ⟨ (Nil, ys)    -> ys
           | (x::xs, ys) -> x::(xs++ys)                
           ⟩;
                   
    xs !! n = 
        if null xs then fail "!!" else 
        if n=0     then hd xs else tl xs !! (n-1);
            
    /* compose  */
    (f $$ g) x = f $ g x;
    (f ∘ g)  x = f $ g x;
    (f ⨾ g)  x = g $ f x;
       
    /* combinators */
    flip  f          = ⟨ (x,y) -> f(y,x) ⟩;
    curry f x y      = f(x,y); 
    uncurry f (x, y) = f x y;
    
    /* reverse  */
    rev = Nil *> flip (::);
    reverse xs = let rv = \( (Nil, r) -> r | (x::xs, r) -> rv (xs, x::r)) in rv (xs, Nil);
    
    /* logic */
    p && q  = if p then q else False;
    p || q  = if p then True else q;
    not x   = if x then False else True; 
    x=/=y   = if x=y then False else True;
    
    zipWith (⊗) xs ys =
    if   null xs && null ys then Nil 
    else hd xs ⊗ hd ys :: zipWith (⊗) (tl xs) (tl ys);
    
    (|||) = λ( (Nil, _) -> Nil
             | (_, Nil) -> Nil
             | (x::xs, y::ys) -> (x,y)::(xs|||ys)
             );
                
    m .. n  = if m>=n then Nil else m :: ((m+1) .. n);
    
    m ... n = if m>n then Nil else m :: ((m+1) ... n);

    takeWhile p = λ
    ( Nil    -> Nil
    | x::xs -> if p x then x::takeWhile p xs else Nil
    );
    
    dropWhile p = λ
    ( Nil    -> Nil
    | x::xs -> if p x then dropWhile p xs else xs
    );

    split p xs = (takeWhile p xs, dropWhile p xs);
    
    filter p =
        ⟨ Nil    -> Nil
        | x::xs -> if p x then x::filter p xs else filter p xs
        ⟩;

    lines = 
        ⟨ Nil -> Nil
        | xs -> let (h, t) = split (=/= '\n') xs in
                    h :: lines t                
        ⟩;
        
     (f×g)(x,y)=(f x, g y)






