--- Pre-CSP with continuations

notation rightdata 3 :: ; 
         data      2 Q ;
         data      0 Nil ;
         id        //;
         right 0 >>> ;;

let {-
       rev  = let f xs = ⟨ Nil → xs | y::ys → f (y::xs) ys⟩ in f Nil; 
       len  = let f xs = ⟨ Nil → xs | y::ys → f (prim_succ xs) ys⟩ in f 0;
       fold c (⊕) = let f r = ⟨ Nil → r | x::xs → f (x⊕r) xs⟩ in f c;
       foldr (⊕) c = let f = ⟨ Nil → c | x::xs → x ⊕ f xs⟩ in f;
       map f = foldr (λ x ys -> f x :: ys) Nil;
       // (⊕) xs = let h::t = xs in foldr ⊕ h t;
    -}
    do  f = foldr (λ x any → f x>>()) ();;
    
let dec r = set r (prim_pred(get r));;
let inc r = set r (prim_succ(get r));;
let (>)   = prim_gr;;


let queueReference() =
    let enqCount  = ref 0;
        deqCount  = ref 0;
        q         = ref(mkQ()) 
    in
    let canDeq()  = candeq(get q);
        enqueue c = inc enqCount >> set q (enq c (get q));
        dequeue() = ⟨ ()      → set q (mkQ())
                    | (nq, r) → inc deqCount >> set q nq >> r
                    ⟩ (deq (get q))
    in (enqueue, dequeue, canDeq, ⟨s → prim_println(s, get q, get enqCount, get deqCount)>>()⟩)
where
    mkQ()    = Q Nil Nil;
    enq c    = ⟨ Q l     r   → Q l (c::r)⟩;
    candeq   = ⟨ Q Nil   Nil → False | other -> True ⟩;
    deq      = ⟨ Q Nil   Nil → ()
               | Q Nil   r   → deq (Q (rev r) Nil)
               | Q (c::l) r   → (Q l r, c)
               ⟩
;;
    
{-
        The scheduler's state is a (single) queue of runnable threads
        represented as continuations
-}

--  Queue manipulation
let (enq, deq, candeq, show) = queueReference();;      

let -- ≡ run the first runnable continuation 
    reschedule()  = if candeq() then deq()() else prim_println "System Terminated" >> ();        
    
    -- ≡ allow another runnable to run if there is one, otherwise resume
    pause() = continue :> (enq continue >> reschedule()); 
    
    -- Construct a schedulable thread from proc. It will invoke continue() on termination of proc().
    mkThread continue proc =  
            resultis :>                       
            ( (resume :> (resultis resume)) >>  --- resume() resumes on the next line [*]
              continue(proc())                  --- [*] call proc then continue. The latter is always a join point                  
            );;                                 --- the result of mkThread is the schedulable continuation at [*]

--- binary parallel composition of unit-functions: runs immediately     
let l || r =
    let count = ref 2 in 
    (join :> 
           ( enq (mkThread join l) >>             
             enq (mkThread join r) >>             
             reschedule()                        
           )
     --- join() resumes here
    ) >>                                 
    if dec count > 0 then reschedule() else ();;

--- generalized parallel composition of unit-functions: runs immediately     
let par procs = 
        let count = ref (len procs) in
        ( join :> 
               ( do enq (map (mkThread join) procs) >> --- make and schedule the new threads
                 reschedule()                          --- start them
               )
        )  >>  --- terminating threads arrive here
        if dec count > 0 then reschedule() else ();;
    


--- Elementary Tests
let pr s  = prim_println s >> pause();;

let l n () = let c = ref 0 in loop (pr ("L1", c) >> pr ("L2", c) >> pause()>> n>inc c);
    r n () = let c = ref 0 in loop (pr ("R1", c) >> pr ("R2", c) >> pause()>> n>inc c);;    
    

let par procs () = par' procs where par' = par;; -- deliver par as a ()->() function



