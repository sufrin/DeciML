--- Pre-CSP with continuations
import "lib/lib.dml";

notation data 2 QUEUE ;; 

let makeQueue() =
    let enqCount  = ref 0;
        deqCount  = ref 0;
        q         = ref(mkQUEUE()) 
    in
    { candeq()  = nonempty !q
    ; enqueue c = inc enqCount >> q := enq c !q
    ; dequeue() = deq !q match 
                    ⟨ ()      → q := (mkQUEUE())
                    | (nq, r) → inc deqCount >> q := nq >> r
                    ⟩ 
    ; show s  = prim_println(s, get q, get enqCount, get deqCount)>>()
    ; reset() = enqCount := 0 >> deqCount := 0 >> q := mkQUEUE()
    }
where
    mkQUEUE()= QUEUE Nil Nil;
    enq c    = ⟨ QUEUE l      r   → QUEUE l (c:r)⟩;
    nonempty = ⟨ QUEUE Nil    Nil → False | _ -> True ⟩;
    deq      = ⟨ QUEUE Nil    Nil → ()
               | QUEUE Nil    r   → deq (QUEUE (rev r) Nil)
               | QUEUE (c:l)  r   → (QUEUE l r, c)
               ⟩
;;
    
{-
        The scheduler's state is a (single) queue of runnable threads
        represented as continuations
-}

--  Scheduler 
let makeRunnable    = schedule.enqueue
  ; runSomething () = schedule.dequeue() ()
  ; anyRunnable     = schedule.candeq
  ; showState       = schedule.show 
  ; reset           = schedule.reset
where 
    schedule=makeQueue()
;;      

let 
    -- run the first runnable continuation 
    reschedule() = if anyRunnable() then runSomething() else prim_println "System Terminated" >> ();        
    
    -- allow another runnable to run if there is one, otherwise resume
    pause() = continue :> (makeRunnable continue >> reschedule()); 
    
    -- Construct a schedulable thread from the thunk expr
    continue `afterevaluating` expr =       -- expr must already be a thunk
        resultis :>                       
        ( (resume :> (resultis resume)) >>  -- resume() resumes on the next line [*]
          continue(force expr)              -- [*] evaluate expr then continue. The latter is always a join point                  
        );;                                 -- the result of mkThread is the schedulable continuation at [*]
    
--- binary parallel composition of unit-expressions: runs immediately     
let (||) = λλλ l r ->
    let count = ref 2 in 
    (join :> 
           ( makeRunnable (join `afterevaluating` r) >>             
             makeRunnable (join `afterevaluating` l) >>             
             reschedule()                        
           )
     --- join() resumes here
    ) >>                                 
    if dec count > 0 then reschedule() else ();;

  
--- Outfix that denotes parallel composition of several thunks    
notation outfix [| |] Nil _consthunk_;;

let _consthunk_ = λλλ e -> λ es -> e : es
  ; ([| . |])   = interleave 
where
     --- parallel composition of thunks: runs immediately     
    interleave thunks = 
        let count = ref (len thunks) in
        ( join :> 
               ( do makeRunnable (map (join `afterevaluating`) thunks) >> --- make the new threads
                 reschedule()                                             --- start them
               )
        )  >>  -- terminating threads arrive here
        if dec count > 0 then reschedule() else ();;
 ;;



--- Elementary Tests of ||, [| . |]
let pr   = prim_println;;
 
let (>+>) = λλλ l r → force l >> pause() >> force r;;

let x s n = let c = ref 0 in loop (pause() >> pr (s, !c) >> n>inc c);;    

-- interleaving order follows order in list
let pp' () = [| x "l" 4, x "m" 5, x "r" 6 |];;

-- interleaving order is  predictable, albeit tediously
let pp  () = x "l" 4 || x "m" 5 || x "r" 6;;
let ppn n  = (x "l" n || x "m" n) || x "r" n;;
let ppn' n  = x "l" n || (x "m" n || x "r" n);;


--- Channels
notation data 1 ReaderWaiting; data 2 WriterWaiting; data  Empty;;

let newChan () = ref Empty;;

let
    write c v = self :> 
                (!c match
                 ⟨ Empty                → (c := WriterWaiting v self) >> reschedule()
                 | ReaderWaiting reader → (c := Empty) >> reader v
                 ⟩
                );
                
    read c = self :>
             (!c match
              ⟨ Empty                  → (c := ReaderWaiting self) >> reschedule()
              | WriterWaiting v writer → (c := Empty >> makeRunnable writer) >> v
              ⟩
             )
;;

---

let ch = newChan(); ch2 = newChan();;

let t1() =  pr(read ch) >+> pr "OKR" || write ch "A" >+> pr "OKL" ;;

let t2() = [| write ch2 "X" >+> pr "W" >+> write ch2 "Y" >+> pr "W'"
           ,  pr(read ch2)  >+> pr "R" >+> pr(read ch2)  >+> pr "R'" |];;





