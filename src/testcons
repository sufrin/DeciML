notation rightdata 3 :  ;
         data nil       ;
         data 1 A B     ;
         data 2 X Y     ;
         right 0 !!     
;;

--+ Some definitions
let null  = λ ( nil -> True | (:) x xs -> False );;
let nullz = λ ( nil -> True | x : xs -> False );;
let isA   = λ ( A x -> True | B x -> False );;
let eX    = (| X x y -> (x,y) |);;
let eY    = λ ( Y x y -> (x,y,z) );;
let ez    = λ x y z -> (x,y,z);;
let (a !! b) = let c=prim_println a in b;;


--+ null nil = True; null (3:nil)=False; ditto for nullz
null    nil;;
null    (3:nil);;
nullz   nil;;
nullz   (3:nil);;

--+ Deconstructions
eX(X 1 2);;
eY(Y 1 2);;
ez 1 2 3;;

--+ Call by need within the body of a lazy function
let mkA   = \\ x -> A x;;
let lazy  = \\ x -> (x,x);;

let p1 (x,y)=x;
    p2 (x,y)=y;;
    
let lez = lazy("ez" !! ez 1 2 3);;

lez;

p1 lez;

force(p1 lez);

lez;;

--+ Deep forcing
let td = lazy (mkA (3:nil));;
td;
deepForce td;

let te = lazy (A (3:nil));;
te;
deepForce te;

--+ Forcing here exposed a typo in the environment construction of thunks
--+ constructed at the application of a lazy function. [Now fixed]
let badA x = A x;;
let tb = lazy (badA (3:nil));; 
tb;
deepForce tb;

--+ Higher order laziness
let pair = \\ i j -> (i, j);;

let pr1 = pair (ez 1 2 3);; pr1;

let pr2 = pr1 (ez 4 5 6);; pr2;

deepForce p2;

--+ Infinite structures, strictness, etc

let delay      = \\ x->x;;
let strict f l = f(force l);;

let head   = strict (| x:xs -> x  |);
    tail   = strict (| x:xs -> xs |);
    isCons = strict (| x:xs -> True | other -> False |) 
    ;;
    
let ident x   = x;
    const x y = x;;
    
let (&&) = (| True -> ident      | False -> const False |);;
let (||) = (| True -> const True | False -> ident |);;

let map f l = if isCons l then f(head l) : delay(map f (tail l)) else nil;;

let succ = prim_succ; pred = prim_pred; (=) = prim_eq; (>) = prim_gr;;

let take n l = if (n>0) && isCons l then head l:take (pred n)(tail l) else nil;;

let ones = 1 : (delay ones);;

let nats = delay (0 : delay(map succ nats));;








